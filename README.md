# mircoservice_arch

1. 看网上的说法，微服务整体的架构是流量网关->api聚合网关->rpc服务。使用api聚合网关实现协议转换（rest->rpc），并且api聚合网关充当聚合多个rpc的作用，相当于让这个服务去调用多个下游拼装结果。
  1. 这样的话，对rpc的粒度就要有很高的要求，我在实践时，一般都是直接让rpc大而全了，也就是让某个rpc去聚合下游rpc的结果，于是api聚合网关在我这里就是啥业务功能都不做了，单纯的协议翻译，也就是gRpc gateway的做法，相当于写的是gRpc Web。
  2. 这种实现的话，也还行。不过有一个问题是，http通常会在header中包含东西，比如用户名，而不会在请求body中包含，对应在grpc中就是metadata，grpc Gateway也有方法去转，问题不大。但是如果对应的gRpc也要给内部调用的话，就要内部服务构造一个metadata的ctx，而不能在请求结构体直接写用户名，挺尬的，没那么直观。但是如果去写两套呢，一套对外一套对内，也有点蠢。
  3. 如果这样来看的话，gRpc只是提供最基础原子的服务才好，其他聚合的功能交给api聚合网关去做。但是我想用rpc就是图他的schema呀！ 不过go-zero给出了一种实现，可以基于schema生成http，但是我用起来感觉还是挺奇怪的，没那么自然，直接从proto解析就好了，没必要自己搞一套声明配置文件规则，不过问题也不大。
